#include <stddef.h>
#include <stdint.h>
#include <assert.h>

#include <oqs/oqs.h>

#include "ot.h"
#include "params.h"
#include "common.h"
#include "group.h"

/// Initialize the OT Receiver
///
/// Initatialize the 1-out-of-n OT Receiver (where n=OTKEM_N).  Provides a
/// secret key for the Receiver and n public keys that make up the message to
/// the Sender.
///
/// @param[out] sk     secret key, of length SK_BYTES
/// @param[out] pks    OTKEM_N public keys, of length PK_BYTES each. Outgoing message to Sender.
/// @param[in]  index  secret index, requires 0<=index<OTKEM_N
/// @param[in]  sid    unique session id, of length SID_BYTES
void kemot_receiver_init(uint8_t sk[SK_BYTES],
                         uint8_t pks[OTKEM_N * PK_BYTES],
                         uint8_t index,
                         const uint8_t sid[SID_BYTES])
{
    size_t i;
    uint8_t swap = 1;
    uint8_t digest[PK_BYTES];
    const uint8_t * pk_pointers[OTKEM_N - 1];
    uint8_t hash_id[HID_BYTES];
    OQS_STATUS rc;

    for (i = 1; i < OTKEM_N; i++) {
        random_pk(&pks[i * PK_BYTES]);
        pk_pointers[i-1] = &pks[i * PK_BYTES];
    }
    for (i = 0; i < SID_BYTES; i++) {
        hash_id[i] = sid[i];
    }
    hash_id[SID_BYTES] = index;
    hash_pks(digest, pk_pointers, hash_id);
    rc = OQS_KEM_kyber_768_keypair(pks, sk);
    assert(rc == OQS_SUCCESS);
    sub_pk(pks, pks, digest);

    // put the last group element in `index`-th place
    for (i = 0; i < OTKEM_N-1; i++) {
        swap &= (-(uint64_t)(i ^ index)) >> 63;
        cswap(&pks[i * PK_BYTES], &pks[(i + 1) * PK_BYTES], PK_BYTES, swap);
    }
}

/// Run the OT Sender
///
/// Run the 1-out-of-n OT Sender (where n=OTKEM_N). Provides n random OT
/// messages (shared secrets) to the Sender and n ciphertexts for the Receiver (so they can
/// decrypt only one of their choice).
///
/// @warning Buffers MUST NOT overlap.
///
/// @param[out] sss  OTKEM_N shared secrets, of length SS_BYTES each
/// @param[out] cts  OTKEM_N ciphertexts, of length CT_BYTES each. Outgoing message to Receiver.
/// @param[in]  pks  OTKEM_N public keys, of length PK_BYTES each. Incoming message from Receiver.
/// @param[in]  sid  unique session id, of length SID_BYTES
void kemot_sender(uint8_t sss[OTKEM_N * SS_BYTES],
                  uint8_t cts[OTKEM_N * CT_BYTES],
                  const uint8_t pks[OTKEM_N * PK_BYTES],
                  const uint8_t sid[SID_BYTES])
{
    uint8_t pk[PK_BYTES];
    const uint8_t * pk_pointers[OTKEM_N - 1];
    uint8_t digest[PK_BYTES];
    uint8_t hash_id[HID_BYTES];
    size_t i;
    OQS_STATUS rc;

    for (i = 0; i < OTKEM_N - 1; i++) {
        pk_pointers[i] = &pks[(i + 1) * PK_BYTES];
    }
    for (i = 0; i < SID_BYTES; i++) {
        hash_id[i] = sid[i];
    }
    hash_id[SID_BYTES] = 0;
    hash_pks(digest, pk_pointers, hash_id);
    add_pk(pk, pks, digest);
    rc = OQS_KEM_kyber_768_encaps(cts, sss, pk);
    assert(rc == OQS_SUCCESS);

    for (i = 1; i < OTKEM_N; i++) {
        pk_pointers[i - 1] = &pks[(i - 1) * PK_BYTES];
        hash_id[SID_BYTES] = i;
        hash_pks(digest, pk_pointers, hash_id);
        add_pk(pk, &pks[i * PK_BYTES], digest);
        rc = OQS_KEM_kyber_768_encaps(&cts[i * CT_BYTES], &sss[i * SS_BYTES], pk);
        assert(rc == OQS_SUCCESS);
    }
}

/// Finalize the OT Receiver
///
/// Finalize the 1-out-of-n OT Receiver (where n=OTKEM_N). Decapsulate the shared secret
/// sent in cts[index], using the sk generated in `kemot_receiver_init`.
///
/// @param[out] ss     shared secret, of length SS_BYTES
/// @param[in]  cts    OTKEM_N ciphertexts, of length CT_BYTES each. Incoming message from Receiver.
/// @param[in]  sk     secret key, of length SK_BYTES. Generated by `kemot_receiver_init`.
/// @param[in]  index  secret index. Must be equal to index passed to `kemot_receiver_init`.
void kemot_receiver_output(uint8_t ss[SS_BYTES],
                           const uint8_t cts[OTKEM_N * CT_BYTES],
                           const uint8_t sk[SK_BYTES],
                           uint8_t index)
{
    uint8_t ct[CT_BYTES];
    uint8_t b;
    size_t i;
    OQS_STATUS rc;

    for (i = 0; i < OTKEM_N; i++) {
        b = 1 - ((-(uint64_t)(i ^ index)) >> 63);
        cmov(ct, &cts[i * CT_BYTES], CT_BYTES, b);
    }
    rc = OQS_KEM_kyber_768_decaps(ss, ct, sk);
    assert(rc == OQS_SUCCESS);
}
