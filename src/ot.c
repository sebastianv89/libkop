#include <stddef.h>
#include <stdint.h>

#include <oqs/oqs.h>

#include "ot.h"
#include "params.h"
#include "common.h"
#include "group.h"

/// Initialize the OT Receiver
///
/// Initatialize the 1-out-of-n OT Receiver (where n=KOP_OT_N).  Provides a
/// secret key for the Receiver and n public keys that make up the message to
/// the Sender.
///
/// @param[out]     sk     secret key, of length KOP_SK_BYTES
/// @param[out]     pks    KOP_OT_N public keys, of length KOP_PK_BYTES each. Outgoing message to Sender.
/// @param[in]      index  secret index, requires 0<=index<KOP_OT_N
/// @param[in]      hid    unique hash id
void kop_ot_recv_init(
    uint8_t sk[KOP_SK_BYTES],
    uint8_t pks[KOP_OT_MSG0_BYTES],
    uint8_t index,
    hid_t *hid)
{
    size_t i;
    uint8_t swap = 1;
    uint8_t digest[KOP_PK_BYTES];
    const uint8_t * pk_pointers[KOP_OT_N - 1];

    for (i = 1; i < KOP_OT_N; i++) {
        random_pk(&pks[i * KOP_PK_BYTES]);
        pk_pointers[i-1] = &pks[i * KOP_PK_BYTES];
    }
    hid->kem = index;
    hash_pks(digest, pk_pointers, hid);
    KOP_KEM_KEYGEN(pks, sk);
    sub_pk(pks, pks, digest);

    // put the last group element in `index`-th place
    for (i = 0; i < KOP_OT_N-1; i++) {
        swap &= (-(uint64_t)(i ^ index)) >> 63;
        cswap(&pks[i * KOP_PK_BYTES], &pks[(i + 1) * KOP_PK_BYTES], KOP_PK_BYTES, swap);
    }
}

/// Run the OT Sender
///
/// Run the 1-out-of-n OT Sender (where n=KOP_OT_N). Provides n random OT
/// messages (shared secrets) to the Sender and n ciphertexts for the Receiver (so they can
/// decrypt only one of their choice).
///
/// @warning Buffers MUST NOT overlap.
///
/// @param[out] sss  KOP_OT_N shared secrets, of length KOP_SS_BYTES each
/// @param[out] cts  KOP_OT_N ciphertexts, of length KOP_CT_BYTES each. Outgoing message to Receiver.
/// @param[in]  pks  KOP_OT_N public keys, of length KOP_PK_BYTES each. Incoming message from Receiver.
/// @param[in]  sid  unique session id, of length KOP_SID_BYTES
void kop_ot_send(
    uint8_t sss[KOP_OT_N * KOP_SS_BYTES],
    uint8_t cts[KOP_OT_MSG1_BYTES],
    const uint8_t pks[KOP_OT_MSG0_BYTES],
    hid_t *hid)
{
    uint8_t pk[KOP_PK_BYTES];
    const uint8_t * pk_pointers[KOP_OT_N - 1];
    uint8_t digest[KOP_PK_BYTES];
    size_t i;

    for (i = 0; i < KOP_OT_N - 1; i++) {
        pk_pointers[i] = &pks[(i + 1) * KOP_PK_BYTES];
    }
    hid->kem = 0;
    hash_pks(digest, pk_pointers, hid);
    add_pk(pk, pks, digest);
    KOP_KEM_ENCAPS(cts, sss, pk);

    for (i = 1; i < KOP_OT_N; i++) {
        pk_pointers[i - 1] = &pks[(i - 1) * KOP_PK_BYTES];
        hid->kem = i;
        hash_pks(digest, pk_pointers, hid);
        add_pk(pk, &pks[i * KOP_PK_BYTES], digest);
        KOP_KEM_ENCAPS(&cts[i * KOP_CT_BYTES], &sss[i * KOP_SS_BYTES], pk);
    }
}

/// Finalize the OT Receiver
///
/// Finalize the 1-out-of-n OT Receiver (where n=KOP_OT_N). Decapsulate the shared secret
/// sent in cts[index], using the sk generated in `kop_otreceiver_init`.
///
/// @param[out] ss     shared secret, of length KOP_SS_BYTES
/// @param[in]  cts    KOP_OT_N ciphertexts, of length KOP_CT_BYTES each. Incoming message from Receiver.
/// @param[in]  sk     secret key, of length KOP_SK_BYTES. Generated by `kop_otreceiver_init`.
/// @param[in]  index  secret index. Must be equal to index passed to `kop_otreceiver_init`.
void kop_ot_recv_out(
    uint8_t ss[KOP_SS_BYTES],
    const uint8_t cts[KOP_OT_MSG1_BYTES],
    const uint8_t sk[KOP_SK_BYTES],
    uint8_t index)
{
    uint8_t ct[KOP_CT_BYTES];
    uint8_t b;
    size_t i;

    for (i = 0; i < KOP_OT_N; i++) {
        b = 1 - ((-(uint64_t)(i ^ index)) >> 63);
        cmov(ct, &cts[i * KOP_CT_BYTES], KOP_CT_BYTES, b);
    }
    KOP_KEM_DECAPS(ss, ct, sk);
}
